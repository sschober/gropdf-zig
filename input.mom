.DOCTYPE DEFAULT
.TITLE "gropdf.zig Test"
.AUTHOR "Sven Schober"
.PRINTSTYLE TYPESET
.PAPER A5
.PT_SIZE 11
.START
.HEADING 1 "Introduction and Motivation"
.PP
.DROPCAP T 2
his file contains only some paragraphs of text. Its purpose is to
showcase some of groff's features und highlight potential rendering
problems in my custom PDF backend, gropdf.zig.
.
.HEADING 2 "Current State"
.PP
.DROPCAP C 2
urrently, a lot of features are implemented: We clearly can typeset
characters, sentences and whole paragraphs. In addition, headings
are working, some glitches have been solved by me. Even Drop Caps
are working, and if you look closely, you will notice the page
number at the bottom.
.PP
The positioning in grout is an interessting topic, as it seems to be
absolute, at first glance. Meaning, there are \*[CODE]H\*[CODE X]
and \*[CODE]V\*[CODE X] absolute coordinates given through all of
the document. 
.PP
But, when ligatures are to be rendered, \*[CODE]C\*[CODE X] commands
are issued and these do not increment the internal drawing position
of the backend device. The same is true for wh commands, which
increment the \*[CODE]x\*[CODE X] drawing position in a relative
way. But in order to be able to compute the new absolute position,
we need to know the current position.
.PP
PDF on the other hand has a text rendering commands
\*[CODE]Tj\*[CODE X], which increases the drawing position
automatically, but we have no way to query the current position as
that is an internal state of the renderer, which lives in the
viewer.
.PP
There was no way around implementing relative positioning in
\*[CODE]gropdf.zig\*[CODE X]\&.
That meant, we need to read the font
description files residing in
\*[CODE]/usr/share/groff/current/font/devpdf/<font name>\*[CODE X],
where for every glyph its width is recorded. We use that when
typsetting words with the \*[CODE]Tj\*[CODE X] command to increase
the internal \*[CODE]y\*[CODE X] axis pointer.

That way positioning improved automatically.
.
.HEADING 2 "Font Selection"
.PP
.DROPCAP S 2
electing the currently correct font is quiet involved, when bridging
\*[CODE]groff_out(5)\*[CODE X] and PDF. Groff issues commands like
the following: \*[CODE]x font 38 TI\*[CODE X] to mount a certain
font at a certain position, but pdf needs a font to be registered on
the document level and then again at the page level. The first
registration yields an object number, the second a page relative
font number. But from the driver, our \*[CODE]Transpiler\*[CODE X]
we are not interessted in the object number, but the index under
which the font was registered in the document's font list, which is
not the same. We memorize both indices and use them during
\*[CODE]fN\*[CODE X], a.ka. font select, operations.
.PP
Before registering a groff font with the document, we need to know
how it is called in PDF. For that, we use a comptime zig map, called
\*[CODE]StaticStringMap\*[CODE X], which is initialized and filled
during compilation.
.HEADING 2 "Character Mapping and Ligatures"
.PP
.DROPCAP L 2
igatures are special character combinations, like 'fi', or 'fl',
that are commonly rendered as one special combined character.
Typographically, this is because 'f' and 'i' for example can fit
closer together than other character combinations.
